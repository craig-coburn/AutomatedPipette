"""This program controls the CNC Liquid Handler with object-oriented Pything GUI using tkinter.

Input:


Output:


Notes:


References:
    https://geekscoders.com/tkinter-tutorial-build-gui-in-python-with-tkinter/
    https://github.com/stonetronics/stoneGcodeSender
    https://forum.arduino.cc/t/demo-of-pc-arduino-comms-using-python/219184/5
    https://github.com/DrD-Flo/OTTO/blob/master/assets/download/G-code-Interpreter-OTTO-Arduino-Firmware.ino
    https://roboticsbackend.com/arduino-interrupts/

    Inspiration:
    https://codereview.stackexchange.com/questions/240378/tkinter-gui-for-running-hplc-pumps-real-time-data-visualization

    Might be useful when create canvas class:
    https://en.wikiversity.org/wiki/Object-Oriented_Programming/GUI_Applications/Python3

    Might be useful for graph:
    https://pythonprogramming.net/how-to-embed-matplotlib-graph-tkinter-gui/

    Helpful:
    https://stackoverflow.com/questions/38229857/how-to-avoid-attributeerror-tkinter-tkapp-object-has-no-attribute-passcheck
"""


import tkinter as tk
import tkinter.scrolledtext as st
from tkinter import *

# For serial port enlistment
import sys
import glob
import serial
from tkinter import filedialog

# Plotting
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg)

# Global variables
global port
global connected
startMarker = '<'
endMarker = '>'
oldBuf = ''
xPosAbs = 0.0
yPosAbs = 0.0
zPosAbs = 0.0
coordList = []
selectedFilePath = ''

class MainWindow(tk.Frame):

    def __init__(self, parent, *args, **kwargs):
        tk.Frame.__init__(self, parent, *args, **kwargs)
        self.parent = parent
        self.initUI()


    def initUI(self):
        """ Configure root window """
        self.parent.title("Liquid Handler Python GUI")
        self.parent.geometry('1450x800')
        self.parent.columnconfigure(0, weight=2)
        self.parent.columnconfigure(1, weight=4)
        self.parent.columnconfigure(2, weight=1)

        """ Column 0 """

        # Serial port chooser
        self.serialPortChooserLabel = tk.Label(self.parent, text='Serial Port:')
        self.serialPortChooserLabel.grid(column=0, row=0, sticky=tk.W, padx=5, pady=5)
        self.serialPortSelection = tk.StringVar()
        self.serialPortSelection.set('')
        self.serialPortOptionMenu = tk.OptionMenu(self.parent, self.serialPortSelection, *self.getSerialPorts())
        self.serialPortOptionMenu.grid(column=0, row=1, sticky=tk.EW, padx=5, pady=5)

        # Update serial port list
        self.serialPortUpdaterLabel = tk.Label(self.parent, text='Update Serial Ports List')
        self.serialPortUpdaterLabel.grid(column=0, row=2, sticky=tk.W, padx=5, pady=5)
        self.serialPortUpdateButton = tk.Button(self.parent, text='Update', command=self.updateSerialPortOptionMenu)
        self.serialPortUpdateButton.grid(column=0, row=3, sticky=tk.EW, padx=5, pady=5)

        # Baud rate
        self.baudRateLabel = tk.Label(self.parent, text='Baud Rate:')
        self.baudRateLabel.grid(column=0, row=4, sticky=tk.W, padx=5, pady=5)
        self.baudRateEntry = tk.StringVar()
        self.baudRateEntry.set('9600')
        Baudlist = ['2400', '4800', '9600', '19200', '38400', '57600', '115200', '230400', '250000']
        self.baudRateOptionMenu = tk.OptionMenu(self.parent, self.baudRateEntry, *Baudlist)
        self.baudRateOptionMenu.grid(column=0, row=5, sticky=tk.EW, padx=5, pady=5)

        # Connection status
        self.statusLabel = tk.Label(self.parent, text='Connection Status:')
        self.statusLabel.grid(column=0, row=6, sticky=tk.W, padx=5, pady=5)
        self.statusIndicator = tk.Text(self.parent, width=14, height=1)
        self.statusIndicator.grid(column=0, row=7, sticky=tk.EW, padx=5, pady=5)
        self.statusIndicator.insert(tk.END, 'DISCONNECTED')
        self.connectButton = tk.Button(self.parent, text="Connect", fg='green', command=self.connect)
        self.connectButton.grid(column=0, row=8, sticky=tk.EW, padx=5, pady=5)
        self.disconnectButton = tk.Button(self.parent, text="Disconnect", fg='red', command=self.disconnect)
        self.disconnectButton.grid(column=0, row=9, sticky=tk.EW, padx=5, pady=5)

        # G-Code import
        self.gcodeSettingsLabel = tk.Label(self.parent, text="Import G-Code")
        self.gcodeSettingsLabel.grid(column=0, row=10, sticky=tk.W, padx=5, pady=5)
        self.fileLabel = tk.Label(self.parent, text="File:")
        self.fileLabel.grid(column=0, row=11, sticky=tk.W, padx=5, pady=5)
        self.selectedFilePath = ''
        self.fileChooserEntryVar = tk.StringVar()
        self.fileChooserEntry = tk.Entry(self.parent, textvariable=self.fileChooserEntryVar)
        self.fileChooserEntry.grid(column=0, row=12, sticky=tk.EW, padx=5, pady=5)

        #TODO: Add SaveAs button for custom gcode files generated by path

        # Buttons for browse, load and save
        self.browseButton = tk.Button(self.parent, text='Browse',width=9, command=self.chooseFile)
        self.browseButton.grid(column=0, row=13, sticky=tk.W, padx=5, pady=5)
        self.loadButton = tk.Button(self.parent, text='Load  ',width=9, command=self.loadFile)
        self.loadButton.grid(column=0, row=13, padx=5, pady=5)
        self.saveButton = tk.Button(self.parent, text='Save  ',width=9, command=self.saveFile)
        self.saveButton.grid(column=0, row=13, sticky=tk.E, padx=5, pady=5)

        # File Display
        self.fileDisplayLabel = tk.Label(self.parent, text="Loaded G-code File:")
        self.fileDisplayLabel.grid(column=0, row=14, sticky=tk.W, padx=5, pady=5)
        self.fileDisplayText = st.ScrolledText(self.parent, width=20, height=10)
        self.fileDisplayText.grid(column=0,row=15,rowspan=2,sticky=tk.EW,padx=5, pady=5)

        self.testData = []
        i = 0
        while i < 100:
            self.testData.append(f'G1 X{i}')
            i += 5

        # Send G-Code Button
        self.sendButtonLabel = tk.Label(self.parent, text='Send G-Code to Machine')
        self.sendButtonLabel.grid(column=0,row=17,rowspan=1,sticky=tk.W,padx=5, pady=5)
        self.sendButton = tk.Button(self.parent, text='Send', command= lambda: self.sendGcode(self.fileAsString))
        self.sendButton.grid(column=0, row=18, sticky=tk.EW, padx=5, pady=5)

        """ Column 1 """

        # Motor jog multiplier
        self.motorJogLabel = tk.Label(self.parent, text="Control")
        self.motorJogLabel.grid(column=1, row=0, sticky=tk.W, padx=5, pady=5)

        # Step size XY
        self.stepXYLabel = tk.Label(self.parent, text="Step size XY (mm):")
        self.stepXYLabel.grid(column=1, row=1, sticky=tk.W, padx=5, pady=5)
        self.stepXY = tk.StringVar()
        self.stepXY.set('1')
        self.stepXYOptionMenu = tk.OptionMenu(self.parent, self.stepXY, *["0.1", "1", "10", "100"])
        self.stepXYOptionMenu.grid(column=1, row=2, sticky=tk.EW, padx=5, pady=5)

        # Step size Z
        self.stepZLabel = tk.Label(self.parent, text="Step size Z (mm):")
        self.stepZLabel.grid(column=1, row=3, sticky=tk.W, padx=5, pady=5)
        self.stepZ = tk.StringVar()
        self.stepZ.set('1')
        self.stepZOptionMenu = tk.OptionMenu(self.parent, self.stepZ, *["0.1", "1", "10", "100"])
        self.stepZOptionMenu.grid(column=1, row=4, sticky=tk.EW, padx=5, pady=5)

        # Motor jog direction
        butW = 10
        self.xPos = tk.Button(self.parent, text='x+', width = butW,command=self.jogCNC_xp)
        self.xPos.grid(column=1, row=6, sticky=tk.E, padx=5, pady=5)
        self.xNeg = tk.Button(self.parent, text='x-', width = butW,command=self.jogCNC_xn)
        self.xNeg.grid(column=1, row=6, sticky=tk.W, padx=5, pady=5)
        self.yPos = tk.Button(self.parent, text='y+', width = butW,command=self.jogCNC_yp)
        self.yPos.grid(column=1, row=5, sticky=tk.N, padx=5, pady=5)
        self.yNeg = tk.Button(self.parent, text='y-', width = butW,command=self.jogCNC_yn)
        self.yNeg.grid(column=1, row=7, sticky=tk.S, padx=5, pady=5)
        self.zPos = tk.Button(self.parent, text='z+', width = butW,command=self.jogCNC_zp)
        self.zPos.grid(column=1, row=5, sticky=tk.NE, padx=5, pady=5)
        self.zNeg = tk.Button(self.parent, text='z-', width = butW,command=self.jogCNC_zn)
        self.zNeg.grid(column=1, row=7, sticky=tk.SE, padx=5, pady=5)

        #TODO: Plunge function to actuate servo OR change plunge function to "zero" function
        self.plunge = tk.Button(self.parent, text='Plunge', width = butW,command=self.moveServo)
        self.plunge.grid(column=1, row=6, padx=5, pady=5)

        # Serial output textbox
        self.serialMonitor = tk.Label(self.parent, text='Serial Monitor')
        self.serialMonitor.grid(column=1, row=8,sticky=tk.W, padx=5, pady=5)
        self.text_box = st.ScrolledText(self.parent, width=20, height=32)
        self.text_box.grid(column=1, row=9, rowspan=16, sticky=tk.EW, padx=5, pady=5)


    def getSerialPorts(self):
        """ Lists serial port names
            :raises EnvironmentError:
                On unsupported or unknown platforms
            :returns:
                A list of the serial ports available on the system
        """
        if sys.platform.startswith('win'):
            ports = ['COM%s' % (i + 1) for i in range(256)]
        elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
            # this excludes your current terminal "/dev/tty"
            ports = glob.glob('/dev/tty[A-Za-z]*')
        elif sys.platform.startswith('darwin'):
            ports = glob.glob('/dev/tty.*')
        else:
            raise EnvironmentError('Unsupported platform')

        result = []
        for port in ports:
            try:
                s = serial.Serial(port)
                s.close()
                result.append(port)
            except (OSError, serial.SerialException):
                pass
        return result


    def updateSerialPortOptionMenu(self):
        self.packOptionMenuEntries(self.serialPortOptionMenu, *self.getSerialPorts())
        if connected:
            port.close()


    def packOptionMenuEntries(self,optionMenu, *entries):
        menu = optionMenu["menu"]
        menu.delete(0, 'end')

        for entry in entries:
            menu.add_command(label=entry, command=lambda entry=entry: self.serialPortSelection.set(entry))


    def connect(self):
        global port
        try:
            port = serial.Serial(self.serialPortSelection.get(), int(self.baudRateEntry.get()), timeout=0, writeTimeout=0)
        except IOError:
            port.close()
            port.open()

        # Wait for "ok" message to be received
        self.waitForArduino()

        connected = True
        self.statusIndicator.delete('1.0', tk.END)
        self.statusIndicator.insert(tk.END, 'CONNECTED')

        # Serial monitor window
        self.readSerial()


    def disconnect(self):
        port.close()
        connected = False
        self.statusIndicator.delete('1.0', tk.END)
        self.statusIndicator.insert(tk.END, 'DISCONNECTED')


    def chooseFile(self):
        global selectedFilePath
        tmp = filedialog.askopenfilename(initialdir="./", title="select gcode file", filetypes=(
            ("gcode files", "*.gcode"), ("gc files", "*.gc"), ("nc files", "*.nc"), ("all files", "*.*")))
        self.fileChooserEntry.delete(0, tk.END)
        self.fileChooserEntry.insert(tk.INSERT, tmp)
        selectedFilePath = tmp  # tkinter seems to overwrite the selectedFilePath somehow, so it gets set again here


    def loadFile(self):
        global selectedFilePath
        selectedFilePath = self.fileChooserEntryVar.get()
        self.fileDisplayText.delete("1.0", tk.END)
        gcodeFile = open(selectedFilePath, 'r')
        self.fileDisplayText.insert(tk.INSERT, gcodeFile.read())
        self.fileAsString = str(self.fileDisplayText.get("1.0", "end-1c"))
        self.fileAsString = self.fileAsString.splitlines()
        gcodeFile.close()


    def saveFile(self):
        global selectedFilePath
        selectedFilePath = self.fileChooserEntryVar.get()
        gcodeFile = open(selectedFilePath, 'w')
        fileContent = self.fileDisplayText.get("1.0", "end-1c")
        gcodeFile.write(fileContent)
        gcodeFile.close()


    """ Wait for a message from the Arduino to give it time to reset """
    def waitForArduino(self):
        # wait until the Arduino ' - allows time for Arduino reset
        # it also ensures that any bytes left over  from a previous message are discarded
        msg = ""

        while msg.find("ok") == -1:
            while port.inWaiting() == 0:
                pass
            msg = self.recvFromArduino()


    def recvFromArduino(self):
        ck = ""
        x = str.encode("z")  # any value that is not an end- or startMarker
        byteCount = -1  # to allow for the fact that the last increment will be one too many
        # wait for the start character
        while x != startMarker:
            x = port.read().decode("ascii")
        # save data until the end marker is found
        while x != endMarker:
            if x != startMarker:
                ck = ck + x
                byteCount += 1
            x = port.read().decode("ascii")

        return ck


    def sendToArduino(self, sendStr):
        """ Write data to Arduino port utf-8 format """
        port.write(sendStr.encode())


    def sendGcode(self, gcode):
        numLoops = len(gcode)
        n = 0
        while n < numLoops:
            gstr = gcode[n]
            # Insert start and end markers
            gstr = ''.join((startMarker, gstr, endMarker))
            self.sendToArduino(gstr)
            self.waitForArduino()
            root.update()
            n += 1


    #TODO: make jogCNC one function rather than 6
    # Also fix jogging functionality because distance given by Arduino IDE does not align with G-Code from jogging functions

    def jogCNC_xp(self):
        """ Send G-Code commands based on user input and chosen multiply factor."""
        global xPosAbs
        xPosAbs += float(self.stepXY.get())
        port.write(str.encode(f'<G1 X{xPosAbs}>'))
        # port.write(str.encode(f'<G1 {}{}>'.format('x',xPosAbs)))


    def jogCNC_xn(self):
        global xPosAbs
        xPosAbs -= float(self.stepXY.get())
        port.write(str.encode(f'<G1 X{xPosAbs}>'))


    def jogCNC_yp(self):
        global yPosAbs
        yPosAbs += float(self.stepXY.get())
        port.write(str.encode(f'<G1 Y{yPosAbs}>'))


    def jogCNC_yn(self):
        global yPosAbs
        yPosAbs -= float(self.stepXY.get())
        port.write(str.encode(f'<G1 Y{yPosAbs}>'))


    def jogCNC_zp(self):
        global zPosAbs
        zPosAbs += float(self.stepZ.get())
        port.write(str.encode(f'<G1 Z{zPosAbs}>'))


    def jogCNC_zn(self):
        global zPosAbs
        zPosAbs -= float(self.stepZ.get())
        port.write(str.encode(f'<G1 Z{zPosAbs}>'))


    def moveServo(self):
        port.write(str.encode('<P1 0.4>')) # Move Servo to 40% of it's range
        # TODO: this is currently not doing anything...


    def readSerial(self):
        newBuf = ''
        global oldBuf
        while True:
            c = port.readline().decode("ascii")  # attempt to read a character from Serial
            # was anything read?
            if len(c) == 0:
                break

            # check if character is a delimeter
            if c == '\r':
                c = ''  # don't want returns. chuck it
            if c == '\n':
                newBuf += "\n"  # add the newline to the buffer

                newBuf = ""  # empty the buffer
            else:
                newBuf += c  # add to the buffer
        if newBuf != oldBuf:
            self.text_box.insert(tk.END, newBuf)
            # Always show most up to date output
            self.text_box.yview(tk.END)
        oldBuf = newBuf

        # text_box.insert(tk.END, serBuffer)
        self.after(10, self.readSerial)  # check serial again soon


class DrawWindow(tk.Canvas, MainWindow):

    """ Creates drawing canvas """
    def __init__(self, parent, *args, **kwargs):
        tk.Canvas.__init__(self, parent, *args, **kwargs)
        self.parent = parent
        self.initCanvas()
        # Bind onclick() function to left mouse button
        self.canvas.bind('<Button-1>', self.onclick)
        self.fillSolCode = []
        self.fillConCode = []
        self.rowChoice = 0


    def initCanvas(self):

        # All distances in mm
        self.sourceLoc = {
            # Row 1: X1 (Beaker)
            8: (30, 0),
            # Row 2: Y1, Y2, Y3
            9: (0, 32.883), 11: (30, 32.883), 13: (60, 32.883),
            # Row 3: Z1, Z2, Z3
            10: (0, 62.883), 12: (30, 62.883), 14: (60, 62.883),
        }

        # Only need to know first column, then can iterate a fixed distance
        self.destLoc = {
            # Col 1: A1 (36), B1, C1, ... H1 (43)
            # Next column to the right is 9mm from the previous
            16: (100.686, -5.957), 17: (100.686, 3.043), 18: (100.686, 12.043), 19: (100.686, 21.043),
            20: (100.686, 30.043), 21: (100.686, 39.043), 22: (100.686, 48.043), 23: (100.686, 57.043)
        }

        self.canvas = Canvas(self.parent)
        self.canvas.config(height=200)
        self.genPathLabel = tk.Label(self.parent, text='Automated Pipette:')
        self.genPathLabel.grid(column=2, row=0, sticky=tk.W, padx=5, pady=5)
        self.sourceLabel = tk.Label(self.parent, text='Select Concentrate:')
        self.sourceLabel.grid(column=2, row=1, sticky=tk.W, padx=5, pady=5)
        self.destLabel = tk.Label(self.parent, text='Select Microplate Row:')
        self.destLabel.grid(column=2, row=1, padx=5, pady=5)

        """ Source rectangle """
        self.canvas.grid(column=2, row=2, sticky=tk.EW, rowspan=6)
        self.canvas.create_rectangle(10, 10, 200, 200, outline='black')
        self.canvas.create_text(50, 20, text="1", fill="black", font=('Helvetica 15 bold'))
        self.canvas.create_text(105, 20, text="2", fill="black", font=('Helvetica 15 bold'))
        self.canvas.create_text(160, 20, text="3", fill="black", font=('Helvetica 15 bold'))
        self.canvas.create_text(25, 70, text="X", fill="black", font=('Helvetica 15 bold'))
        self.canvas.create_text(25, 125, text="Y", fill="black", font=('Helvetica 15 bold'))
        self.canvas.create_text(25, 170, text="Z", fill="black", font=('Helvetica 15 bold'))

        # Circles
        self.create_circle(105, 70, 25, self.canvas) # Beaker
        self.create_circle(50, 125, 15, self.canvas) # LHS
        self.create_circle(50, 170, 15, self.canvas)
        self.create_circle(105, 125, 15, self.canvas) # MIDDLE
        self.create_circle(105, 170, 15, self.canvas)
        self.create_circle(160, 125, 15, self.canvas)  # RHS
        self.create_circle(160, 170, 15, self.canvas)

        """ Destination rectangle """
        self.canvas.create_rectangle(220, 10, 550, 200, outline='black')
        self.canvas.create_text(240, 35, text="A", fill="blue", font=('Helvetica 11 bold underline'))
        self.canvas.create_text(240, 56.4, text="B", fill="blue", font=('Helvetica 11 bold underline'))
        self.canvas.create_text(240, 77.8, text="C", fill="blue", font=('Helvetica 11 bold underline'))
        self.canvas.create_text(240, 99.2, text="D", fill="blue", font=('Helvetica 11 bold underline'))
        self.canvas.create_text(240, 120.6, text="E", fill="blue", font=('Helvetica 11 bold underline'))
        self.canvas.create_text(240, 142, text="F", fill="blue", font=('Helvetica 11 bold underline'))
        self.canvas.create_text(240, 163.4, text="G", fill="blue", font=('Helvetica 11 bold underline'))
        self.canvas.create_text(240, 185, text="H", fill="blue", font=('Helvetica 11 bold underline'))

        self.canvas.create_text(260, 20, text="1", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(283.6, 20, text="2", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(307.2, 20, text="3", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(330.8, 20, text="4", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(354.4, 20, text="5", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(378, 20, text="6", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(401.6, 20, text="7", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(425.2, 20, text="8", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(448.8, 20, text="9", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(472.4, 20, text="10", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(496, 20, text="11", fill="black", font=('Helvetica 11 bold'))
        self.canvas.create_text(519.6, 20, text="12", fill="black", font=('Helvetica 11 bold'))

        # Circles for microplate
        x = 260
        while x <= 520:
            self.create_circle(x, 35, 8, self.canvas)
            self.create_circle(x, 56.4, 8, self.canvas)
            self.create_circle(x, 77.8, 8, self.canvas)
            self.create_circle(x, 99.2, 8, self.canvas)
            self.create_circle(x, 120.6, 8, self.canvas)
            self.create_circle(x, 142, 8, self.canvas)
            self.create_circle(x, 163.4, 8, self.canvas)
            self.create_circle(x, 184.8, 8, self.canvas)
            # Each column 45 across
            x += 23.6

        self.runButton = tk.Button(self.parent, text='Run', width=15,
                                   command=lambda: [self.fillCon(), MainWindow.sendGcode(self, self.fillConCode)])
        self.runButton.grid(column=2, row=9, padx=20, pady=5)

        # Buttons and labels after canvas
        self.sendPathLabel = tk.Label(self.parent, text='Serial Dilution:')
        self.sendPathLabel.grid(column=2, row=8, sticky=tk.W, padx=5, pady=5)
        self.fillSolButton = tk.Button(self.parent, text='Fill Row', width=15,
                                       command=lambda: [self.fillSol(), MainWindow.sendGcode(self, self.fillSolCode)])
        self.fillSolButton.grid(column=2, row=9, sticky=tk.W, padx=5, pady=5)

        # Text box for errors:
        self.errorLabel = tk.Label(self.parent, text='Status:')
        self.errorLabel.grid(column=2, row=10, sticky=tk.W, padx=5, pady=5)
        self.errorText = tk.Text(self.parent, width=10, height=1)
        self.errorText.grid(column=2, row=11, sticky=tk.EW, padx=5, pady=5)

        # Initialize item as empty tuple
        self.item = ()


    def onclick(self,event):
        """ # Change the color of object when it is clicked
            from: https://stackoverflow.com/questions/38982313/python-tkinter-identify-object-on-click
        """
        self.item = self.canvas.find_closest(event.x, event.y)
        self.item_type = self.canvas.type(self.item)
        self.current_color = self.canvas.itemcget(self.item, 'fill')
        if self.item_type == "oval" and self.item[0] < 15 and self.item[0] > 8:
            if self.current_color == 'white':
                self.canvas.itemconfig(self.item[0], fill='sky blue')
            else:
                self.canvas.itemconfig(self.item[0], fill='white')
        if self.item_type == "text" and self.item[0] > 15 and self.item[0] < 24:
            if self.current_color == 'blue':
                self.canvas.itemconfig(self.item[0], fill='red')
            else:
                self.canvas.itemconfig(self.item[0], fill='blue')


    def create_circle(self, x, y, r, canvas):
        x0 = x - r
        y0 = y - r
        x1 = x + r
        y1 = y + r
        return self.canvas.create_oval(x0, y0, x1, y1, fill='white')


    def fillSol(self):

        """ Fill microplate row with solution (water) """
        if len(self.item) == 0:
            self.errorText.delete('1.0', tk.END)
            self.errorText.insert(tk.END, 'Select a microplate row to disperse stock solution')
        else:
            self.errorText.delete('1.0', tk.END)

        numCols = 12
        xPos = self.destLoc[self.item[0]][0]
        yPos = self.destLoc[self.item[0]][1]
        self.rowChoice = self.item[0]  # Keep track of which row was chosen
        print(f'row: {self.rowChoice}')
        if self.item[0] in self.destLoc:
            self.errorText.delete('1.0', tk.END)
            self.errorText.insert(tk.END, 'Filling microplate row with stock solution')
            while numCols > 0:
                self.fillSolCode.append('M1 P0')  # Move servo to top position
                self.fillSolCode.append(f'G1 X{self.sourceLoc[8][1]} Y{self.sourceLoc[8][0]}')
                # self.fillSolCode.append(f'G1 Y{self.sourceLoc[8][0]}')            # Beaker
                # Move z-axis and plunge
                self.fillSolCode.append('G1 Z-80') # Move z-axis down
                self.fillSolCode.append('M1 P1')  # Actuate pipette
                self.fillSolCode.append('M1 P0')  # Move servo to top position
                self.fillSolCode.append('G1 Z0')  # Bring z-axis back up

                self.fillSolCode.append(f'G1 X{yPos} Y{xPos}')
                # self.fillSolCode.append(f'G1 Y{xPos}')   # Microplate
                # Move z-axis and plunge
                self.fillSolCode.append('G1 Z-80')  # Move z-axis down
                self.fillSolCode.append('M1 P1')  # Actuate pipette
                self.fillSolCode.append('G1 Z0')  # Bring z-axis back up

                # Coord list is probably not correct right now
                # coordList.append((self.destLoc[self.item[0]][0], self.destLoc[self.item[0]][1]))

                # Next column
                numCols -= 1

                # Mixed up x-pos and y-pos, change this eventually
                xPos += 9

            # Go back to the zero position
            self.fillSolCode.append('G1 X0 Y0 Z0')



    def fillCon(self):

        """ Fill microplate row with solution and perform serial dilution over this row """
        numCols = 12
        sourceChoice = 9 # default
        # Chosen source:
        if self.item[0] < 15:
            sourceChoice = self.item[0]

        print(sourceChoice)
        self.rowChoice = self.item[0]  # Keep track of which row was chosen
        xPos = self.destLoc[self.rowChoice][1]
        yPos = self.destLoc[self.rowChoice][0]
        if self.rowChoice == 0:
            self.errorText.delete('1.0', tk.END)
            self.errorText.insert(tk.END, 'You must first fill a row with stock solution')
        else:
            if sourceChoice in self.sourceLoc and sourceChoice > 8:
                # First dispense concentrate into first row
                self.fillConCode.append('M1 P0')  # Release pipette
                self.fillConCode.append(f'G1 X{self.sourceLoc[sourceChoice][1]} Y{self.sourceLoc[sourceChoice][0]}')
                # self.fillConCode.append(f'G1 Y{self.sourceLoc[sourceChoice][1]}')
                self.fillConCode.append('M1 P1')  # Actuate pipette
                self.fillConCode.append('G1 Z-60')  # Move z-axis down
                self.fillConCode.append('M1 P0')  # Release pipette
                self.fillConCode.append('G1 Z0')  # Bring z-axis back up
                while numCols > 0:
                    print(f'print this: {self.fillConCode}')
                    # Go to dest loc column 1
                    self.fillConCode.append(f'G1 X{xPos} Y{yPos}')
                    # self.fillConCode.append(f'G1 Y{yPos}')   # Microplate
                    self.fillConCode.append('G1 Z-84')  # Move z-axis down
                    self.fillConCode.append('M1 P1')  # Actuate pipette
                    self.fillConCode.append('M1 P0')  # Release pipette
                    self.fillConCode.append('G1 Z-50')  # Bring z-axis back up
                    numCols -= 1
                    yPos += 9

        # Go back to the zero position
        self.fillConCode.append('G1 X0 Y0 Z0')


# TODO: figure out how to plot this data LIVE rather than only plot it once

class PlotWindow(tk.Frame):

    def __init__(self, parent, *args, **kwargs):
        tk.Frame.__init__(self, parent, *args, **kwargs)
        self.parent = parent
        self.initGraph()


    def initGraph(self):
        # Plotting label and button
        self.posLabel = tk.Label(self.parent, text='G-code Plot:')
        self.posLabel.grid(column=2, row=12, sticky=tk.W, padx=5, pady=5)

        # Create figure
        fig = plt.figure(figsize=(6, 1), dpi=40)
        plt.axes(xlim=(0, 210), ylim=(0, 115))
        # Grid on both axis
        plt.gca().yaxis.grid(True)
        plt.gca().xaxis.grid(True)
        plt.title('Absolute Position')
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        self.plotcanvas = FigureCanvasTkAgg(fig, master=self.parent)
        # plotcanvas.draw()
        self.plotcanvas.get_tk_widget().grid(column=2, row=13, rowspan=10, sticky=tk.NS, ipadx=5, ipady=5)
        self.plotcanvas.get_tk_widget().configure(highlightthickness=1)

        # Button to plot data
        self.plotData = tk.Button(self.parent, text='Plot G-code Path', width = 15, command=self.plotGraph)
        self.plotData.grid(column=2, row=9, sticky=tk.E, padx=10, pady=5)


    def plotGraph(self):
        x_val = [x[0] for x in coordList]
        y_val = [x[1] for x in coordList]
        plt.plot(x_val, y_val, marker="x")
        self.plotcanvas.draw()


if __name__ == "__main__":
    root = tk.Tk()
    main = MainWindow(root)
    draw = DrawWindow(root)
    plot = PlotWindow(root)
    root.mainloop()

